if (length(ptcs_before_domain_posns) > 0) {
if (ptc_survival[ptcs_before_domain_posns[length(ptcs_before_domain_posns)]]) {
return('Dispensable')
}
}
}  else if (any(ptc_positions < dom_end & !ptc_survival)) {
ptcs_after_lethal_ptc <- ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)]
# All PTCs after the lethal one are tolerated, or the lethal PTC is the last
# PTC in the gene
if (all(ptcs_after_lethal_ptc)) {
return('Essential')
}
}
return('Ambiguous')
}
args <- c("~/Desktop/smsk_microsporidia_domains/data/PTC_data/supp_11.xls",
"~/Desktop/smsk_microsporidia_domains/data/PTC_data/yeast_genome_to_uniprot.rds",
"~/Desktop/smsk_microsporidia_domains/results/all_yeast_domains/yeast_domains_resolved.txt",
"~/Desktop/smsk_microsporidia_domains/results/Fig_2/Fig_2B/merged_DA_alignments_checked.csv",
"~/Desktop/smsk_microsporidia_domains/data/excluded_species.txt")
ptc <- readxl::read_xls(args[1]) %>%
# remove rows for PTCs without yeast survival status
filter(!is.na(`HMM PTC classification`))
sgd_to_uniprot <- readRDS(args[2])
yeast_domain_archs <- read_delim(args[3], delim = ' ', show_col_types = F) %>%
# add column indicating last residue each domain in protein
mutate(dom_start = get_domain_start(resolved),
dom_end = get_domain_end(resolved)) %>%
group_by(`query-id`) %>%
mutate(n_dom = row_number()) %>%
ungroup() %>%
# Add column for end of domain preceding each domain in a protein, if not
# the first (or only) domain in a protein
mutate(preceding_dom_end = ifelse(n_dom != 1,
lag(dom_end),
NA))
# split into separate tibbles for each yeast protein
yeast_domain_archs <- split(yeast_domain_archs, yeast_domain_archs$`query-id`)
aligned_DA <- read_csv(args[4], show_col_types = F) %>%
filter(!(species %in% readLines(args[5])))
out <- args[6]
# add column to PTC dataset for uniprot names of yeast genes
ptc <- ptc %>%
rowwise() %>%
mutate(gene_uniprot = sgd_to_uniprot[[Gene]]) %>%
select(Gene, gene_uniprot, everything())
# Use supp table 11 (PTC data) to annotate domains in yeast proteins as
# essential, dispensable, or otherwise unclassifiable (see methods)
ptc_annotated_genes <- unique(ptc$gene_uniprot)
for (prt in names(yeast_domain_archs)) {
if (!(prt %in% ptc_annotated_genes)) {
# No PTC data for this yeast protein, so classify all domains as unclassified
yeast_domain_archs[[prt]]$domain_classification <- 'Unclassified'
} else {
# Get PTC data for this particular yeast gene
prt_ptc_data <- filter(ptc, gene_uniprot == prt)
# Get vectors of PTC positions (relative to portein coordinates) and
# tolerance of PTCs
ptc_positions <-
rev(prt_ptc_data$CDS_length - prt_ptc_data$dist_from_CDS_end)
ptc_survival <-
rev(sapply(prt_ptc_data$`HMM PTC classification`,
function(x) {ifelse(x == 'A', TRUE, FALSE)}))
# Add column to each yeast protein domain architecture dataframe, indicating
# whether each domain in the protein is dispensable, essential or
# unclassifiable (see methods)
yeast_domain_archs[[prt]] <- yeast_domain_archs[[prt]] %>%
rowwise() %>%
mutate(domain_classification =
classify_domain(dom_start, dom_end, ptc_positions, ptc_survival))
}
}
# Annotate lost domains in microsporidia orthologs as dispensable, etc, using
# yeast_domain_archs
annotated_dom_losses <- annotate_dom_losses(aligned_DA, yeast_domain_archs)
# Make plot of blah blah blah
SP_ORDER <- SP_ORDER[!(SP_ORDER %in% excluded_sp)]
plt <- ggplot(filter(annotated_dom_losses, lost_dom_classification != 'Unclassified'),
aes(x = species, fill = lost_dom_classification)) +
geom_bar(position = 'fill') +
coord_flip() +
theme_bw() +
labs(y = '% of annotated lost domains in species') +
scale_fill_manual('Lost domain classification',
values = c('black', '#008080', '#DC143C')) +
scale_x_discrete(limits = rev(SP_ORDER)) +
theme(axis.title.y = element_blank(),
axis.text.y = element_text(color = 'black', size = 10),
axis.title.x = element_text(color = 'black', size = 14),
axis.text.x = element_text(color = 'black', size = 12))
################################################################################
yeast_domain_archs_df <- bind_rows(yeast_domain_archs)
annotated_count <- filter(annotated_dom_losses,
!(lost_dom_classification %in% c('Unclassified', 'Ambiguous')))
yeast_annotated_count <- filter(yeast_domain_archs_df,
!(domain_classification %in% c('Unclassified', 'Ambiguous'))) %>%
group_by(domain_classification) %>%
summarise(n = n())
n_dispensable_yeast <- yeast_annotated_count$n[1]
n_essential_yeast <- yeast_annotated_count$n[2]
species <- unique(annotated_dom_losses$species)
sp_p_vals <- list()
for (sp in species) {
sp_df <- filter(annotated_count, species == sp) %>%
group_by(lost_dom_classification) %>%
summarise(n = n())
n_dispensable <- sp_df$n[1]
n_essential <- ifelse(!is.na(sp_df$n[2]), sp_df$n[2], 0)
count_table <- matrix(c(n_dispensable, n_essential,
n_dispensable_yeast, n_essential_yeast),
ncol = 2)
colnames(count_table) <- c(sp, 'yeast')
rownames(count_table) <- c('dispensable', 'essential')
count_table <- as.table(count_table)
p_val <- fisher.test(count_table)$p.value
sp_p_vals[[sp]] <- p_val
}
# -----------------------------------------------------------------------------
#
# Annotate essentiality/dispensability of yeast protein domains from premature
# stop codon data
#
# Jason Jiang - Created: 2022/03/07
#               Last edited: 2022/04/26
#
# Reinke Lab - Microsporidia Orthologs Project
#
# Goal: Using supp. table 11 from X et al's 2018 paper, infer dispensible
#       C-terminal domains in yeast proteins using premature stop codon effects
#       on yeast viability.
#
# Thanks to Brandon Murareanu for this RScript layout
#
#
# -----------------------------------------------------------------------------
suppressMessages(library(tidyverse))
################################################################################
# Ordering of microsporidia species
SP_ORDER <- c('A_alge', 'A_locu', 'E_aedi', 'E_bien', 'E_brev', 'E_canc',
'E_cuni', 'E_hell', 'E_hepa', 'E_inte', 'E_roma', 'H_erio',
'N_ausu', 'N_cera', 'N_cide', 'N_disp', 'N_ferr', 'N_gran',
'N_homo', 'N_iron', 'N_majo', 'N_mino', 'N_okwa', 'N_pari',
'O_coll', 'P_epip', 'P_phil', 'S_loph', 'T_cont', 'T_homi',
'T_rati', 'V_corn', 'V_culi', 'A_sp.', 'M_incu', 'M_daph',
'P_sacc', 'R_allo')
################################################################################
# [1] "~/Desktop/smsk_microsporidia_domains/data/PTC_data/supp_11.xls"
# [2] "~/Desktop/smsk_microsporidia_domains/data/PTC_data/yeast_genome_to_uniprot.rds"
# [3] "~/Desktop/smsk_microsporidia_domains/results/all_yeast_domains/yeast_domains_resolved.txt"
# [4] "~/Desktop/smsk_microsporidia_domains/results/Fig_2/Fig_2B/merged_DA_alignments_checked.csv"
# [5] "~/Desktop/smsk_microsporidia_domains/data/excluded_species.txt"
main <- function() {
# ----------------------------------------------------------------------------
# Command line arguments:
#   $1 = filepath to supp. table 11 from X et al's paper (PTC effects on yeast
#        viability)
#
#   $2 = filepath to hashtable mapping SGD gene names to Uniprot names
#        (from map_sgd_names_to_uniprot.R)
#
#   $3 = cath-resolve-hits output for resolved domain architecture of all
#        yeast proteins
#
#   $4 = aligned domain architectures of all ortholog pairs
#
#   $5 = txt file of Microsporidia species to exclude
#
#   $6 = filepath to save output files from this script into
# ----------------------------------------------------------------------------
# Parse in command line arguments
args <- commandArgs(trailingOnly = T)
ptc <- readxl::read_xls(args[1]) %>%
# remove rows for PTCs without yeast survival status
filter(!is.na(`HMM PTC classification`))
sgd_to_uniprot <- readRDS(args[2])
yeast_domain_archs <- read_delim(args[3], delim = ' ', show_col_types = F) %>%
# add column indicating last residue each domain in protein
mutate(dom_start = get_domain_start(resolved),
dom_end = get_domain_end(resolved)) %>%
group_by(`query-id`) %>%
mutate(n_dom = row_number()) %>%
ungroup() %>%
# Add column for end of domain preceding each domain in a protein, if not
# the first (or only) domain in a protein
mutate(preceding_dom_end = ifelse(n_dom != 1,
lag(dom_end),
NA))
# split into separate tibbles for each yeast protein
yeast_domain_archs <- split(yeast_domain_archs, yeast_domain_archs$`query-id`)
aligned_DA <- read_csv(args[4], show_col_types = F) %>%
filter(!(species %in% readLines(args[5])))
out <- args[6]
# add column to PTC dataset for uniprot names of yeast genes
ptc <- ptc %>%
rowwise() %>%
mutate(gene_uniprot = sgd_to_uniprot[[Gene]]) %>%
select(Gene, gene_uniprot, everything())
# Use supp table 11 (PTC data) to annotate domains in yeast proteins as
# essential, dispensable, or otherwise unclassifiable (see methods)
ptc_annotated_genes <- unique(ptc$gene_uniprot)
for (prt in names(yeast_domain_archs)) {
if (!(prt %in% ptc_annotated_genes)) {
# No PTC data for this yeast protein, so classify all domains as unclassified
yeast_domain_archs[[prt]]$domain_classification <- 'Unclassified'
} else {
# Get PTC data for this particular yeast gene
prt_ptc_data <- filter(ptc, gene_uniprot == prt)
# Get vectors of PTC positions (relative to portein coordinates) and
# tolerance of PTCs
ptc_positions <-
rev(prt_ptc_data$CDS_length - prt_ptc_data$dist_from_CDS_end)
ptc_survival <-
rev(sapply(prt_ptc_data$`HMM PTC classification`,
function(x) {ifelse(x == 'A', TRUE, FALSE)}))
# Add column to each yeast protein domain architecture dataframe, indicating
# whether each domain in the protein is dispensable, essential or
# unclassifiable (see methods)
yeast_domain_archs[[prt]] <- yeast_domain_archs[[prt]] %>%
rowwise() %>%
mutate(domain_classification =
classify_domain(dom_start, dom_end, ptc_positions, ptc_survival))
}
}
# Annotate lost domains in microsporidia orthologs as dispensable, etc, using
# yeast_domain_archs
annotated_dom_losses <- annotate_dom_losses(aligned_DA, yeast_domain_archs)
# Make plot of blah blah blah
SP_ORDER <- SP_ORDER[!(SP_ORDER %in% excluded_sp)]
plt <- ggplot(filter(annotated_dom_losses, lost_dom_classification != 'Unclassified'),
aes(x = species, fill = lost_dom_classification)) +
geom_bar(position = 'fill') +
coord_flip() +
theme_bw() +
labs(y = '% of annotated lost domains in species') +
scale_fill_manual('Lost domain classification',
values = c('black', '#008080', '#DC143C')) +
scale_x_discrete(limits = rev(SP_ORDER)) +
theme(axis.title.y = element_blank(),
axis.text.y = element_text(color = 'black', size = 10),
axis.title.x = element_text(color = 'black', size = 14),
axis.text.x = element_text(color = 'black', size = 12))
################################################################################
yeast_domain_archs_df <- bind_rows(yeast_domain_archs)
annotated_count <- filter(annotated_dom_losses,
!(lost_dom_classification %in% c('Unclassified', 'Ambiguous')))
yeast_annotated_count <- filter(yeast_domain_archs_df,
!(domain_classification %in% c('Unclassified', 'Ambiguous'))) %>%
group_by(domain_classification) %>%
summarise(n = n())
n_dispensable_yeast <- yeast_annotated_count$n[1]
n_essential_yeast <- yeast_annotated_count$n[2]
species <- unique(annotated_dom_losses$species)
sp_p_vals <- list()
for (sp in species) {
sp_df <- filter(annotated_count, species == sp) %>%
group_by(lost_dom_classification) %>%
summarise(n = n())
n_dispensable <- sp_df$n[1]
n_essential <- ifelse(!is.na(sp_df$n[2]), sp_df$n[2], 0)
count_table <- matrix(c(n_dispensable, n_essential,
n_dispensable_yeast, n_essential_yeast),
ncol = 2)
colnames(count_table) <- c(sp, 'yeast')
rownames(count_table) <- c('dispensable', 'essential')
count_table <- as.table(count_table)
p_val <- fisher.test(count_table)$p.value
sp_p_vals[[sp]] <- p_val
}
# Save the plot or something idk
ggsave(plot = plt, filename = str_c(out, '/Fig_2C.tiff'),
units = 'in', width = 6.99, height = 6.38)
}
################################################################################
### Helper functions
get_domain_start <- Vectorize(function(resolved_boundaries) {
# ----------------------------------------------------------------------------
# Returns position of the fast residue of a domain in a protein
# Vectorized to with dplyr mutate
#
# Arguments:
#   resolved_boundaries: 'resolved' column entry from a cath-resolve-hits
#                         domain architecture file
# ----------------------------------------------------------------------------
domain_segments <- str_split(resolved_boundaries, ',')[[1]]
first_segment <- domain_segments[1]
end <- str_split(first_segment, '-')[[1]][1]
return(end)
})
get_domain_end <- Vectorize(function(resolved_boundaries) {
# ----------------------------------------------------------------------------
# Returns position of the last residue of a domain in a protein
# Vectorized to with dplyr mutate
#
# Arguments:
#   resolved_boundaries: 'resolved' column entry from a cath-resolve-hits
#                         domain architecture file
# ----------------------------------------------------------------------------
domain_segments <- str_split(resolved_boundaries, ',')[[1]]
last_segment <- domain_segments[length(domain_segments)]
end <- str_split(last_segment, '-')[[1]][2]
return(end)
})
map_yeast_genes_to_archs <- function(ortho_pairs, domain_archs_dir) {
# ----------------------------------------------------------------------------
# Returns a list mapping yeast uniprot gene names to dataframes of their domain
# architectures (from cath-resolve-hits)
#
# Arguments:
#   ortho_pairs: dataframe w/ info on all microsporidia - yeast gene pairs,
#                from compare_sco_lengths snakefile
#
#   domain_archs_dir: filepath to directory with all cath-resolve-hits
#                     domain architectures for each microsporidia - yeast
#                     ortholog pair
# ----------------------------------------------------------------------------
# Extract each unique ortholog conserved between yeast and microsporidia
# Use the species, orthogroup and ortholog name information later to load
# in domain architecture information for each yeast ortholog
yeast_orthos <- ortho_pairs %>%
select(species, orthogroup, yeast_ortho) %>%
distinct(yeast_ortho, .keep_all = T)
# use above dataframe to load in domain arch data for all yeast orthologs to
# microsporidia
yeast_domain_archs <- list()
for (i in 1 : nrow(yeast_orthos)) {
# filepath to cath-resolve-hits domain architecture file for this yeast
# ortholog to microsporidia
crh_file <- str_c(domain_archs_dir, str_c(yeast_orthos$species[i], '_S_cere'),
yeast_orthos$orthogroup[i], 'crh',
yeast_orthos$yeast_ortho[i], sep = '/')
# add entry to yeast_domain_archs, with key as uniprot name of yeast
# ortholog and value as dataframe of the cath-resolve-hits domain
# architecture file
yeast_domain_archs[[yeast_orthos$yeast_ortho[i]]] <-
read_delim(file = crh_file, comment = '#', col_names = CRH_HEADER,
delim = ' ', show_col_types = FALSE) %>%
# add a column for the end boundaries of each domain in the ortholog
mutate(dom_start = get_domain_start(resolved),
dom_end = get_domain_end(resolved))
}
return(yeast_domain_archs)
}
classify_domain <- function(dom_start, dom_end, ptc_positions, ptc_survival) {
# ----------------------------------------------------------------------------
# Use PTC data to annotate a protein domain as dispensable, essential or
# unclassifiable (see methods)
#
# Arguments:
#   dom_end: position of last residue of protein domain in the protein
#   ptc_positions: vector of residues where PTCs were inserted into the gene
#                  for the protein
#   ptc_survival: vector of logicals indicating whether each PTC from ptc_positions
#                 is tolerated by yeast or not
# ----------------------------------------------------------------------------
# PTC occurs BEFORE the domain and is tolerated
# get most N-terminal PTC to the domain, BEFORE start of domain
# check if that PTC is tolerated -> if so, then truly dispensable
if (any(ptc_positions < dom_start & ptc_survival)) {  # note to self: any(c()) returns False
ptcs_before_domain_posns <- which(ptc_positions < dom_start)
if (length(ptcs_before_domain_posns) > 0) {
if (ptc_survival[ptcs_before_domain_posns[length(ptcs_before_domain_posns)]]) {
return('Dispensable')
}
}
}  else if (any(ptc_positions < dom_end & !ptc_survival)) {
ptcs_after_lethal_ptc <- ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)]
# All PTCs after the lethal one are tolerated, or the lethal PTC is the last
# PTC in the gene
if (all(ptcs_after_lethal_ptc)) {
return('Essential')
}
}
return('Ambiguous')
}
get_lost_dom_positions <- Vectorize(function(aligned_DA) {
# ----------------------------------------------------------------------------
# Helper function to annotate_dom_losses
# ----------------------------------------------------------------------------
microsp_DA <- str_split(
str_split(aligned_DA, ' \\| ')[[1]][1],
''
)[[1]]
# Return positions of DA alignment where microsporidia ortholog is missing
# domains
return(str_c(which(microsp_DA == '*'), collapse = ', '))
})
classify_lost_doms <- function(lost_dom_position, yeast_domain_arch_df) {
# ----------------------------------------------------------------------------
# Helper function to annotate_dom_losses
# ----------------------------------------------------------------------------
return(
yeast_domain_arch_df$domain_classification[as.integer(lost_dom_position)]
)
}
annotate_dom_losses <- function(aligned_DA, yeast_domain_archs) {
# ----------------------------------------------------------------------------
# Blah
# ----------------------------------------------------------------------------
annotated_dom_losses <- aligned_DA %>%
select(species, yeast, microsp_DA, yeast_DA, aligned_DA, lost_doms) %>%
# filter to only orthologs w/ lost domains, and where yeast ortholog is
# annotated in PTC data
filter(!is.na(lost_doms), yeast %in% names(yeast_domain_archs)) %>%
mutate(lost_dom_position = get_lost_dom_positions(aligned_DA)) %>%
separate_rows(lost_doms, lost_dom_position, sep = ',') %>%
rowwise() %>%
mutate(lost_dom_classification = classify_lost_doms(lost_dom_position,
yeast_domain_archs[[yeast]]))
return(annotated_dom_losses)
}
ptc <- readxl::read_xls(args[1]) %>%
# remove rows for PTCs without yeast survival status
filter(!is.na(`HMM PTC classification`))
sgd_to_uniprot <- readRDS(args[2])
yeast_domain_archs <- read_delim(args[3], delim = ' ', show_col_types = F) %>%
# add column indicating last residue each domain in protein
mutate(dom_start = get_domain_start(resolved),
dom_end = get_domain_end(resolved)) %>%
group_by(`query-id`) %>%
mutate(n_dom = row_number()) %>%
ungroup() %>%
# Add column for end of domain preceding each domain in a protein, if not
# the first (or only) domain in a protein
mutate(preceding_dom_end = ifelse(n_dom != 1,
lag(dom_end),
NA))
# split into separate tibbles for each yeast protein
yeast_domain_archs <- split(yeast_domain_archs, yeast_domain_archs$`query-id`)
aligned_DA <- read_csv(args[4], show_col_types = F) %>%
filter(!(species %in% readLines(args[5])))
out <- args[6]
# add column to PTC dataset for uniprot names of yeast genes
ptc <- ptc %>%
rowwise() %>%
mutate(gene_uniprot = sgd_to_uniprot[[Gene]]) %>%
select(Gene, gene_uniprot, everything())
# Use supp table 11 (PTC data) to annotate domains in yeast proteins as
# essential, dispensable, or otherwise unclassifiable (see methods)
ptc_annotated_genes <- unique(ptc$gene_uniprot)
for (prt in names(yeast_domain_archs)) {
if (!(prt %in% ptc_annotated_genes)) {
# No PTC data for this yeast protein, so classify all domains as unclassified
yeast_domain_archs[[prt]]$domain_classification <- 'Unclassified'
} else {
# Get PTC data for this particular yeast gene
prt_ptc_data <- filter(ptc, gene_uniprot == prt)
# Get vectors of PTC positions (relative to portein coordinates) and
# tolerance of PTCs
ptc_positions <-
rev(prt_ptc_data$CDS_length - prt_ptc_data$dist_from_CDS_end)
ptc_survival <-
rev(sapply(prt_ptc_data$`HMM PTC classification`,
function(x) {ifelse(x == 'A', TRUE, FALSE)}))
# Add column to each yeast protein domain architecture dataframe, indicating
# whether each domain in the protein is dispensable, essential or
# unclassifiable (see methods)
yeast_domain_archs[[prt]] <- yeast_domain_archs[[prt]] %>%
rowwise() %>%
mutate(domain_classification =
classify_domain(dom_start, dom_end, ptc_positions, ptc_survival))
}
}
# Annotate lost domains in microsporidia orthologs as dispensable, etc, using
# yeast_domain_archs
annotated_dom_losses <- annotate_dom_losses(aligned_DA, yeast_domain_archs)
# Make plot of blah blah blah
SP_ORDER <- SP_ORDER[!(SP_ORDER %in% excluded_sp)]
plt <- ggplot(filter(annotated_dom_losses, lost_dom_classification != 'Unclassified'),
aes(x = species, fill = lost_dom_classification)) +
geom_bar(position = 'fill') +
coord_flip() +
theme_bw() +
labs(y = '% of annotated lost domains in species') +
scale_fill_manual('Lost domain classification',
values = c('black', '#008080', '#DC143C')) +
scale_x_discrete(limits = rev(SP_ORDER)) +
theme(axis.title.y = element_blank(),
axis.text.y = element_text(color = 'black', size = 10),
axis.title.x = element_text(color = 'black', size = 14),
axis.text.x = element_text(color = 'black', size = 12))
################################################################################
yeast_domain_archs_df <- bind_rows(yeast_domain_archs)
annotated_count <- filter(annotated_dom_losses,
!(lost_dom_classification %in% c('Unclassified', 'Ambiguous')))
yeast_annotated_count <- filter(yeast_domain_archs_df,
!(domain_classification %in% c('Unclassified', 'Ambiguous'))) %>%
group_by(domain_classification) %>%
summarise(n = n())
n_dispensable_yeast <- yeast_annotated_count$n[1]
n_essential_yeast <- yeast_annotated_count$n[2]
species <- unique(annotated_dom_losses$species)
sp_p_vals <- list()
for (sp in species) {
sp_df <- filter(annotated_count, species == sp) %>%
group_by(lost_dom_classification) %>%
summarise(n = n())
n_dispensable <- sp_df$n[1]
n_essential <- ifelse(!is.na(sp_df$n[2]), sp_df$n[2], 0)
count_table <- matrix(c(n_dispensable, n_essential,
n_dispensable_yeast, n_essential_yeast),
ncol = 2)
colnames(count_table) <- c(sp, 'yeast')
rownames(count_table) <- c('dispensable', 'essential')
count_table <- as.table(count_table)
p_val <- fisher.test(count_table)$p.value
sp_p_vals[[sp]] <- p_val
}
yeast_domain_archs_df
view(yeast_domain_archs_df)
yeast_domain_archs_df %>%
group_by(domain_classification) %>%
summarise(n = n())

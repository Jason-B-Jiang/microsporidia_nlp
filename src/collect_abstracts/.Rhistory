# ----------------------------------------------------------------------------
microsp_DA <- str_split(
str_split(aligned_DA, ' \\| ')[[1]][1],
''
)[[1]]
# Return positions of DA alignment where microsporidia ortholog is missing
# domains
return(str_c(which(microsp_DA == '*'), collapse = ', '))
})
classify_lost_doms <- function(lost_dom_position, yeast_domain_arch_df) {
# ----------------------------------------------------------------------------
# Helper function to annotate_dom_losses
# ----------------------------------------------------------------------------
return(
yeast_domain_arch_df$domain_classification[as.integer(lost_dom_position)]
)
}
annotate_dom_losses <- function(aligned_DA, yeast_domain_archs) {
# ----------------------------------------------------------------------------
# Blah
# ----------------------------------------------------------------------------
annotated_dom_losses <- aligned_DA %>%
select(species, yeast, microsp_DA, yeast_DA, aligned_DA, lost_doms) %>%
# filter to only orthologs w/ lost domains, and where yeast ortholog is
# annotated in PTC data
filter(!is.na(lost_doms), yeast %in% names(yeast_domain_archs)) %>%
mutate(lost_dom_position = get_lost_dom_positions(aligned_DA)) %>%
separate_rows(lost_doms, lost_dom_position, sep = ',') %>%
rowwise() %>%
mutate(lost_dom_classification = classify_lost_doms(lost_dom_position,
yeast_domain_archs[[yeast]]))
return(annotated_dom_losses)
}
args <- c("~/Desktop/smsk_microsporidia_domains/data/PTC_data/supp_11.xls", "~/Desktop/smsk_microsporidia_domains/data/PTC_data/yeast_genome_to_uniprot.rds", "~/Desktop/smsk_microsporidia_domains/results/all_yeast_domains/yeast_domains_resolved.txt", "~/Desktop/smsk_microsporidia_domains/results/Fig_2/Fig_2B/merged_DA_alignments.csv", "~/Desktop/smsk_microsporidia_domains/data/excluded_species.txt"   )
ptc <- readxl::read_xls(args[1]) %>%
# remove rows for PTCs without yeast survival status
filter(!is.na(`HMM PTC classification`))
sgd_to_uniprot <- readRDS(args[2])
yeast_domain_archs <- read_delim(args[3], delim = ' ', show_col_types = F) %>%
# add column indicating last residue each domain in protein
mutate(dom_end = get_domain_end(resolved))
# split into separate tibbles for each yeast protein
yeast_domain_archs <- split(yeast_domain_archs, yeast_domain_archs$`query-id`)
aligned_DA <- read_csv(args[4], show_col_types = F) %>%
filter(!(species %in% readLines(args[5])))
# add column to PTC dataset for uniprot names of yeast genes
ptc <- ptc %>%
rowwise() %>%
mutate(gene_uniprot = sgd_to_uniprot[[Gene]]) %>%
select(Gene, gene_uniprot, everything())
# Use supp table 11 (PTC data) to annotate domains in yeast proteins as
# essential, dispensable, or otherwise unclassifiable (see methods)
ptc_annotated_genes <- unique(ptc$gene_uniprot)
for (prt in names(yeast_domain_archs)) {
if (!(prt %in% ptc_annotated_genes)) {
# No PTC data for this yeast protein, so classify all domains as unclassified
yeast_domain_archs[[prt]]$domain_classification <- 'Unclassified'
} else {
# Get PTC data for this particular yeast gene
prt_ptc_data <- filter(ptc, gene_uniprot == prt)
# Get vectors of PTC positions (relative to portein coordinates) and
# tolerance of PTCs
ptc_positions <-
rev(prt_ptc_data$CDS_length - prt_ptc_data$dist_from_CDS_end)
ptc_survival <-
rev(sapply(prt_ptc_data$`HMM PTC classification`,
function(x) {ifelse(x == 'A', TRUE, FALSE)}))
# Add column to each yeast protein domain architecture dataframe, indicating
# whether each domain in the protein is dispensable, essential or
# unclassifiable (see methods)
yeast_domain_archs[[prt]] <- yeast_domain_archs[[prt]] %>%
rowwise() %>%
mutate(domain_classification =
classify_domain(dom_end, ptc_positions, ptc_survival))
}
}
delete_me <- bind_rows(yeast_domain_archs)
view(delete_me)
view(filter(delete_me, domain_classification != 'Unclassified'))
view(ptc)
501 - 9
prt = 'P00549'
prt_ptc_data <- filter(ptc, gene_uniprot == prt)
view(prt_ptc_data)
ptc_positions <-
rev(prt_ptc_data$CDS_length - prt_ptc_data$dist_from_CDS_end)
ptc_survival <-
rev(sapply(prt_ptc_data$`HMM PTC classification`,
function(x) {ifelse(x == 'A', TRUE, FALSE)}))
ptc_positions
ptc_survival
dom_end <- 498
any(ptc_positions < dom_end & ptc_survival)
any(ptc_positions < dom_end & !ptc_survival)
all(ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)])
which(ptc_positions < dom_end & !ptc_survival)
ptc_positions
dom_end
-which(ptc_positions < dom_end & !ptc_survival)
ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)]
all(ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)])
ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)]
length(ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)])
length(ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)])
test = ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)]
if length(test) > 0
length(test) > 0
length(test) > 0 & all(test)
all(test)
ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)]
classify_domain <- function(dom_end, ptc_positions, ptc_survival) {
# ----------------------------------------------------------------------------
# Use PTC data to annotate a protein domain as dispensable, essential or
# unclassifiable (see methods)
#
# Arguments:
#   dom_end: position of last residue of protein domain in the protein
#   ptc_positions: vector of residues where PTCs were inserted into the gene
#                  for the protein
#   ptc_survival: vector of logicals indicating whether each PTC from ptc_positions
#                 is tolerated by yeast or not
# ----------------------------------------------------------------------------
# PTC disrupts domain by occurring before its end, with yeast surviving
if (any(ptc_positions < dom_end & ptc_survival)) {
return('Dispensable')
# PTC within or before the domain is lethal, and all PTCs after this
# domain-disrupting lethal PTC are tolerated
} else if (any(ptc_positions < dom_end & !ptc_survival)) {
ptcs_after_lethal_ptc <- ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)]
# There are PTCs after the lethal PTC, and all of them are tolerated
if (length(ptcs_after_lethal_ptc) > 0 & all(ptcs_after_lethal_ptc)) {
return('Essential')
}
}
return('Ambiguous')
}
ptc_positions
ptc_survival
classify_domain(498, ptc_positions, ptc_survival)
classify_domain(365, ptc_positions, ptc_survival)
for (prt in names(yeast_domain_archs)) {
if (!(prt %in% ptc_annotated_genes)) {
# No PTC data for this yeast protein, so classify all domains as unclassified
yeast_domain_archs[[prt]]$domain_classification <- 'Unclassified'
} else {
# Get PTC data for this particular yeast gene
prt_ptc_data <- filter(ptc, gene_uniprot == prt)
# Get vectors of PTC positions (relative to portein coordinates) and
# tolerance of PTCs
ptc_positions <-
rev(prt_ptc_data$CDS_length - prt_ptc_data$dist_from_CDS_end)
ptc_survival <-
rev(sapply(prt_ptc_data$`HMM PTC classification`,
function(x) {ifelse(x == 'A', TRUE, FALSE)}))
# Add column to each yeast protein domain architecture dataframe, indicating
# whether each domain in the protein is dispensable, essential or
# unclassifiable (see methods)
yeast_domain_archs[[prt]] <- yeast_domain_archs[[prt]] %>%
rowwise() %>%
mutate(domain_classification =
classify_domain(dom_end, ptc_positions, ptc_survival))
}
}
delete_me <- bind_rows(yeast_domain_archs)
colnames(delete_me)
delete_me %>%
group_by(domain_classification) %>%
summarise(count = n())
view(delete_me)
delete_me_2 <- delete_me
classify_domain <- function(dom_end, ptc_positions, ptc_survival) {
# ----------------------------------------------------------------------------
# Use PTC data to annotate a protein domain as dispensable, essential or
# unclassifiable (see methods)
#
# Arguments:
#   dom_end: position of last residue of protein domain in the protein
#   ptc_positions: vector of residues where PTCs were inserted into the gene
#                  for the protein
#   ptc_survival: vector of logicals indicating whether each PTC from ptc_positions
#                 is tolerated by yeast or not
# ----------------------------------------------------------------------------
# PTC disrupts domain by occurring before its end, with yeast surviving
if (any(ptc_positions < dom_end & ptc_survival)) {
return('Dispensable')
# delete this block later
} else if (any(ptc_positions < dom_end & !ptc_survival) &
all(ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)])) {
return('Essential')
# PTC within or before the domain is lethal, and all PTCs after this
# domain-disrupting lethal PTC are tolerated
}
# else if (any(ptc_positions < dom_end & !ptc_survival)) {
#   ptcs_after_lethal_ptc <- ptc_survival[-which(ptc_positions < dom_end & !ptc_survival)]
#
#   # There are PTCs after the lethal PTC, and all of them are tolerated
#   if (length(ptcs_after_lethal_ptc) > 0 & all(ptcs_after_lethal_ptc)) {
#     return('Essential')
#   }
# }
return('Ambiguous')
}
yeast_domain_archs <- read_delim(args[3], delim = ' ', show_col_types = F) %>%
# add column indicating last residue each domain in protein
mutate(dom_end = get_domain_end(resolved))
# split into separate tibbles for each yeast protein
yeast_domain_archs <- split(yeast_domain_archs, yeast_domain_archs$`query-id`)
ptc_annotated_genes <- unique(ptc$gene_uniprot)
for (prt in names(yeast_domain_archs)) {
if (!(prt %in% ptc_annotated_genes)) {
# No PTC data for this yeast protein, so classify all domains as unclassified
yeast_domain_archs[[prt]]$domain_classification <- 'Unclassified'
} else {
# Get PTC data for this particular yeast gene
prt_ptc_data <- filter(ptc, gene_uniprot == prt)
# Get vectors of PTC positions (relative to portein coordinates) and
# tolerance of PTCs
ptc_positions <-
rev(prt_ptc_data$CDS_length - prt_ptc_data$dist_from_CDS_end)
ptc_survival <-
rev(sapply(prt_ptc_data$`HMM PTC classification`,
function(x) {ifelse(x == 'A', TRUE, FALSE)}))
# Add column to each yeast protein domain architecture dataframe, indicating
# whether each domain in the protein is dispensable, essential or
# unclassifiable (see methods)
yeast_domain_archs[[prt]] <- yeast_domain_archs[[prt]] %>%
rowwise() %>%
mutate(domain_classification =
classify_domain(dom_end, ptc_positions, ptc_survival))
}
}
delete_me <- bind_rows(yeast_domain_archs)
delete_me %>%
group_by(domain_classification) %>%
summarise(count = n())
delete_me_2 %>%
group_by(domain_classification) %>%
summarise(count = n())
install.packages('diffdf')
library(diffdf)
diffdf(delete_me, delete_me_2)
diffs <- diffdf(delete_me, delete_me_2)
view(diffs)
view(delete_me)
view(delete_me_2)
all(delete_me$`match-id` == delete_me_2$`match-id`)
delete_me[1:3,]
colnames(diffs)
class(diffs)
names(diffs)
?diffdf
as.data.frame(diffs)
diffs_df <- as.data.frame(diffs)
view(diffs_df)
colnames(diffs_df)
diffs_1 <- delete_me[diffs_df$VarDiff_domain_classification...ROWNUMBER..,]
diffs_2 <- delete_me_2[diffs_df$VarDiff_domain_classification...ROWNUMBER..]
diffs_2 <- delete_me_2[diffs_df$VarDiff_domain_classification...ROWNUMBER..,]
view(diffs_1)
view(diffs_2)
diff_prts <- unique(diffs_1$`query-id`)
diff_prts[1]
view(delete_me)
view(ptc)
ptc_diff_prts <- filter(ptc, gene_uniprot %in% diff_prts)
view(ptc_diff_prts)
length(unique(ptc_diff_prts$`HMM PTC classification`))
delete_me %>%
group_by(domain_classification) %>%
summarise(count = n())
delete_me_2 %>%
group_by(domain_classification) %>%
summarise(count = n())
view(delete_me_2)
length(unique(ptc_diff_prts$`HMM PTC classification`))
unique(ptc_diff_prts$`HMM PTC classification`)
annotated_dom_losses <- annotate_dom_losses(aligned_DA, yeast_domain_archs)
ggplot(filter(annotated_dom_losses, lost_dom_classification != 'Unclassified'),
aes(x = species, fill = lost_dom_classification)) +
geom_bar(position = 'fill') +
coord_flip() +
theme_bw() +
labs(y = '% of annotated lost domains in species') +
scale_fill_manual('Lost domain classification',
values = c('black', '#008080', '#DC143C')) +
scale_x_discrete(limits = rev(SP_ORDER)) +
theme(axis.title.y = element_blank(),
axis.text.y = element_text(color = 'black', size = 10),
axis.title.x = element_text(color = 'black', size = 14),
axis.text.x = element_text(color = 'black', size = 12))
delete_me_2 %>%
group_by(domain_classification) %>%
summarise(count = n())
70 / (332 + 70)
332 / (332 + 70)
delete_me %>%
group_by(domain_classification) %>%
summarise(count = n())
ptc
check_ptc_intolerant <- function(ptc_survival) {
return(all(ptc_survival == 'D'))
}
check_ptc_intolerant <- Vectorize(function(ptc_survival) {
return(all(ptc_survival == 'D'))
})
view(ptc)
ptc <- ptc %>%
group_by(gene_uniprot) %>%
mutate(ptc_intolerant = check_ptc_intolerant(`HMM PTC classification`))
view(ptc)
ptc$ptc_intolerant
sum(ptc$ptc_intolerant)
check <- filter(ptc, ptc_intolerant)
view(check)
unique(check$`HMM PTC classification`)
check <- filter(ptc, !ptc_intolerant)
unique(check$`HMM PTC classification`)
check_ptc_intolerant <- function(prt) {
prt_ptc <- filter(ptc, gene_uniprot == prt)
}
check_ptc_intolerant <- function(prt) {
prt_ptc <- filter(ptc, gene_uniprot == prt)
}
check_ptc_intolerant <- function(prt) {
prt_ptc <- filter(ptc, gene_uniprot == prt)
all(prt_ptc$`HMM PTC classification` == 'D')
}
prts <- unique(ptc$gene_uniprot)
length(prts)
ptc_intolerant <- c()
for (prt in prts) {
if (check_ptc_intolerant(prt)) {}
}
for (prt in prts) {
if (check_ptc_intolerant(prt)) {
ptc_intolerant <- append(ptc_intolerant, prt)
}
}
length(check_ptc_intolerant())
length(ptc_intolerant)
517 / 1034
view(delete_me)
intersect(unique(delete_me$`query-id`), ptc$gene_uniprot)
length(intersect(unique(delete_me$`query-id`), ptc$gene_uniprot))
ptc_intolerant
intersect(unique(delete_me$`query-id`), ptc_intolerant)
length(intersect(unique(delete_me$`query-id`), ptc_intolerant))
489 / 973
ptc <- ptc %>%
mutate(ptc_position = CDS_length - dist_from_CD)
ptc <- ptc %>%
mutate(ptc_position = CDS_length - dist_from_CDS_end)
view(ptc)
view(ptc)
colnames(ptc)
ptc$ptc_position
ptc['ptc_intolerant']
ptc[-'ptc_intolerant']
ptc[-50]
view(ptc[-50])
ptc <- ptc[-50]
view(delete_me)
view(delete_me)
last_ptc_before_domain <- function(prt) {
prt_ptc <- filter(ptc, gene_uniprot == prt)
last_dom_end <- max(filter(delete_me, `query-id` == prt)$dom_end)
}
last_ptc_before_domain <- function(prt) {
prt_ptc <- filter(ptc, gene_uniprot == prt)
last_dom_end <- max(filter(delete_me, `query-id` == prt)$dom_end)
}
last_ptc_before_domain <- function(prt) {
prt_ptc <- filter(ptc, gene_uniprot == prt)
last_dom_end <- max(filter(delete_me, `query-id` == prt)$dom_end)
print(last_dom_end)
}
last_ptc_before_domain('P25386')
last_ptc_before_domain <- function(prt) {
prt_ptc <- filter(ptc, gene_uniprot == prt)
last_dom_end <- max(as.integer(filter(delete_me, `query-id` == prt)$dom_end))
print(last_dom_end)
}
last_ptc_before_domain('P25386')
last_ptc_before_domain <- function(prt) {
prt_ptc <- filter(ptc, gene_uniprot == prt)
last_dom_end <- max(as.integer(filter(delete_me, `query-id` == prt)$dom_end))
last_ptc <- max(as.integer(prt_ptc$ptc_position))
print(last_dom_end)
print(last_ptc)
}
last_ptc_before_domain('P25386')
last_ptc_before_domain <- function(prt) {
prt_ptc <- filter(ptc, gene_uniprot == prt)
last_dom_end <- max(as.integer(filter(delete_me, `query-id` == prt)$dom_end))
last_ptc <- max(as.integer(prt_ptc$ptc_position))
print(last_dom_end)
print(last_ptc)
return(last_ptc < last_dom_end)
}
last_ptc_before_domain('P25386')
last_ptc_before_domain <- function(prt) {
prt_ptc <- filter(ptc, gene_uniprot == prt)
last_dom_end <- max(as.integer(filter(delete_me, `query-id` == prt)$dom_end))
last_ptc <- max(as.integer(prt_ptc$ptc_position))
return(last_ptc < last_dom_end)
}
annotated_prts <- unique(filter(delete_me, domain_classification != 'Unclassified')$`query-id`)
last_ptc_before_domain_prts <- c()
for (prt in annotated_prts) {
if (last_ptc_before_domain(prt)) {
last_ptc_before_domain_prts <- append(last_ptc_before_domain_prts, prt)
}
}
length(last_ptc_before_domain_prts)
350 / 973
intersect(last_ptc_before_domain_prts, ptc_intolerant)
length(intersect(last_ptc_before_domain_prts, ptc_intolerant))
library(tidyverse)
library(readxl)
library(writexl)
install.packages('writexl')
library(writexl)
?rename
# -----------------------------------------------------------------------------
#
# Organize microsporidia species papers
#
# Jason Jiang - Created: 2022/05/02
#               Last edited: 2022/05/09
#
# Mideo Lab
#
# Select microsporidia species for analysis and extract first papers describing
# each species.
#
#
# -----------------------------------------------------------------------------
library(tidyverse)
library(writexl)
################################################################################
# Supplemental table S1 from Murareanu et al. 2021 (Microsporidia species dataset)
microsp_data <- read_csv('../../data/microsporidia_species.csv')
# Exclude any species coming from these papers
# I'll talk more about this during lab meeting
excluded_papers <- readLines('../../data/excluded_papers.txt')
microsp_data %>%
rename(species = `Species Name`)
get_year_first_identified <- Vectorize(function(years) {
# ----------------------------------------------------------------------------
# Get the first year a Microsporidia species was described in, as an integer
#
# Input:
#   years: entry from the 'Date Identified (year)' column from microsporidia
#          species dataset
# ----------------------------------------------------------------------------
return(as.integer(str_remove(str_split(years, '; ')[[1]][1], ' \\(.+')))
})
get_first_reference <- Vectorize(function(ref) {
# ----------------------------------------------------------------------------
# Get reference for the first paper describing a particular Microsporidia species
#
# Input:
#   ref: entry from References column of Microsporidia dataset
# ----------------------------------------------------------------------------
return(str_remove(trimws(str_split(ref, '\n')[[1]][1]), '^\\d\\. '))
})
excluded_papers <- readLines('../../data/excluded_papers.txt')
microsp_data <- microsp_data %>%
rename(species = `Species Name`) %>%
mutate(year_first_described = get_year_first_identified(`Date Identified (year)`),
first_paper_reference = get_first_reference(References),
first_paper_title = NA,
abstract = NA,
notes = NA,
# Is the paper in a foreign language?
foreign = NA) %>%
# filter out cases where year first described is unknown or ambiguous
# (NA or '?' in the microsporidia dataset for Date Identified)
filter(!is.na(year_first_described) & !str_detect(year_first_described, '?'),
# Filter microsporidia species to species from 1977 to 2021
# Species from before 1977 come from Sprague book
year_first_described >= 1977) %>%
rowwise() %>%
filter(!any(str_detect(References, excluded_papers))) %>%
select(species, year_first_described, first_paper_reference,
first_paper_title, abstract, notes, foreign) %>%
arrange(year_first_described)
microsp_data <- read_csv('../../data/microsporidia_species.csv')
# Exclude any species coming from these papers
# I'll talk more about this during lab meeting
excluded_papers <- readLines('../../data/excluded_papers.txt')
microsp_data <- microsp_data %>%
rename(species = `Species Name`) %>%
mutate(year_first_described = get_year_first_identified(`Date Identified (year)`),
first_paper_reference = get_first_reference(References),
first_paper_title = NA,
abstract = NA,
notes = NA,
# Is the paper in a foreign language?
foreign = NA) %>%
# filter out cases where year first described is unknown or ambiguous
# (NA or '?' in the microsporidia dataset for Date Identified)
filter(!is.na(year_first_described) & !str_detect(year_first_described, '\\?'),
# Filter microsporidia species to species from 1977 to 2021
# Species from before 1977 come from Sprague book
year_first_described >= 1977) %>%
rowwise() %>%
filter(!any(str_detect(References, excluded_papers))) %>%
select(species, year_first_described, first_paper_reference,
first_paper_title, abstract, notes, foreign) %>%
arrange(year_first_described)
view(microsp_data)
